
mod builtin;
mod io;
mod ssv;
mod iter;
mod list;
mod str;

mod tests {
    proc enumerate(caller, @next) {
        let (caller, @next) = caller(@yield, @parseint_list_of_str);
        let (caller, @next) = caller(@yield, @parseint_list_of_list_of_str);
        let (caller, @next) = caller(@yield, @transpose2_empty);
        let (caller, @next) = caller(@yield, @transpose2_single_row);
        let (caller, @next) = caller(@yield, @transpose2_single_col);
        let (caller, @next) = caller(@yield, @transpose2_full);
        let (caller, @next) = caller(@yield, @multi_iter_map_empty);
        let (caller, @next) = caller(@yield, @multi_iter_map_full);
        let () = caller(@eos);        
    }

    mod cases {
        proc parseint_list_of_str(caller) {
            let (p) = this.super.super.parseint_list_of_str;

            let (@req, p, @next) = p(@next);
            let (@req, p, @next) = p(@start);
            let (@req, p, @next) = p(@yield, '1');
            let (@req, p, @next) = p(@yield, '2');
            let (@req, p, @next) = p(@yield, '3');
            let (@resp, p, @yield, 123) = p(@eos);
            let (@req, p, @next) = p(@next);
            let (@req, p, @next) = p(@start);
            let (@req, p, @next) = p(@yield, '4');
            let (@req, p, @next) = p(@yield, '5');
            let (@req, p, @next) = p(@yield, '6');
            let (@resp, p, @yield, 456) = p(@eos);
            let (@req, p, @next) = p(@next);
            let (@resp, p, @eos) = p(@eos);
            
            let () = caller(@pass);
        }

        proc parseint_list_of_list_of_str(caller) {
            let (p) = this.super.super.parseint_list_of_list_of_str;

            let (@req, p, @next) = p(@next);
            let (@resp, p, @start) = p(@start);

            let (@req, p, @next) = p(@next);
            let (@req, p, @next) = p(@start);
            let (@req, p, @next) = p(@yield, '1');
            let (@req, p, @next) = p(@yield, '2');
            let (@req, p, @next) = p(@yield, '3');
            let (@resp, p, @yield, 123) = p(@eos);

            let (@req, p, @next) = p(@next);
            let (@req, p, @next) = p(@start);
            let (@req, p, @next) = p(@yield, '4');
            let (@req, p, @next) = p(@yield, '5');
            let (@req, p, @next) = p(@yield, '6');
            let (@resp, p, @yield, 456) = p(@eos);
            
            let (@req, p, @next) = p(@next);
            let (@resp, p, @eos) = p(@eos);

            let (@req, p, @next) = p(@next);
            let (@resp, p, @start) = p(@start);

            let (@req, p, @next) = p(@next);
            let (@req, p, @next) = p(@start);
            let (@req, p, @next) = p(@yield, '1');
            let (@req, p, @next) = p(@yield, '2');
            let (@req, p, @next) = p(@yield, '3');
            let (@resp, p, @yield, 123) = p(@eos);
            
            let (@req, p, @next) = p(@next);
            let (@resp, p, @eos) = p(@eos);

            let (@req, p, @next) = p(@next);
            let (@resp, p, @eos) = p(@eos);
            
            let () = caller(@pass);
        }
        
        proc transpose2_empty(caller) {
            let (list) = this.super.super.list.new();

            let (t) = this.super.super.transpose2(list);
            let (@resp, t, @eos) = t(@next);

            let () = caller(@pass);
        }

        proc transpose2_single_row(caller) {
            let (row) = this.super.super.list.new();
            let (@resp, row) = row(@push_back, @foo);
            let (@resp, row) = row(@push_back, @bar);
            let (@resp, row) = row(@push_back, @baz);

            let (list) = this.super.super.list.new();
            let (@resp, list) = list(@push_back, row);

            let (t) = this.super.super.transpose2(list);
            let (@resp, t, @start) = t(@next);
            let (@resp, t, @yield, @foo) = t(@next);
            let (@resp, t, @eos) = t(@next);
            let (@resp, t, @start) = t(@next);
            let (@resp, t, @yield, @bar) = t(@next);
            let (@resp, t, @eos) = t(@next);
            let (@resp, t, @start) = t(@next);
            let (@resp, t, @yield, @baz) = t(@next);
            let (@resp, t, @eos) = t(@next);
            let (@resp, t, @eos) = t(@next);
            
            let () = caller(@pass);
        }

        proc transpose2_single_col(caller) {
            let (list) = this.super.super.list.new();

            let (row) = this.super.super.list.new();
            let (@resp, row) = row(@push_back, @foo);
            let (@resp, list) = list(@push_back, row);
            
            let (row) = this.super.super.list.new();
            let (@resp, row) = row(@push_back, @bar);
            let (@resp, list) = list(@push_back, row);
            
            let (row) = this.super.super.list.new();
            let (@resp, row) = row(@push_back, @baz);
            let (@resp, list) = list(@push_back, row);

            let (t) = this.super.super.transpose2(list);
            let (@resp, t, @start) = t(@next);
            let (@resp, t, @yield, @foo) = t(@next);
            let (@resp, t, @yield, @bar) = t(@next);
            let (@resp, t, @yield, @baz) = t(@next);
            let (@resp, t, @eos) = t(@next);
            let (@resp, t, @eos) = t(@next);
            
            let () = caller(@pass);
        }

        proc transpose2_full(caller) {
            let (list) = this.super.super.list.new();

            let (row) = this.super.super.list.new();
            let (@resp, row) = row(@push_back, @foo);
            let (@resp, row) = row(@push_back, @bar);
            let (@resp, list) = list(@push_back, row);
            
            let (row) = this.super.super.list.new();
            let (@resp, row) = row(@push_back, @baz);
            let (@resp, row) = row(@push_back, @qux);
            let (@resp, list) = list(@push_back, row);
            
            let (row) = this.super.super.list.new();
            let (@resp, row) = row(@push_back, 1);
            let (@resp, row) = row(@push_back, 2);
            let (@resp, list) = list(@push_back, row);

            let (t) = this.super.super.transpose2(list);
            let (@resp, t, @start) = t(@next);
            let (@resp, t, @yield, @foo) = t(@next);
            let (@resp, t, @yield, @baz) = t(@next);
            let (@resp, t, @yield, 1) = t(@next);
            let (@resp, t, @eos) = t(@next);
            let (@resp, t, @start) = t(@next);
            let (@resp, t, @yield, @bar) = t(@next);
            let (@resp, t, @yield, @qux) = t(@next);
            let (@resp, t, @yield, 2) = t(@next);
            let (@resp, t, @eos) = t(@next);
            let (@resp, t, @eos) = t(@next);
            
            let () = caller(@pass);
        }

        proc parseint_factory(caller) {
            let (p) = this.super.super.str.parseint2();
            let () = caller(p);
            become this.parseint_factory()
        }
                
        proc multi_iter_map_empty(caller) {
            let (m) = this.super.super.multi_iter_map(this.parseint_factory);

            let (@req, m, @next) = m(@next);
            let (@end, @eos) = m(@eos);
            let () = caller(@pass);
        }    
    
        proc multi_iter_map_full(caller) {
            let (m) = this.super.super.multi_iter_map(this.parseint_factory);

            let (@req, m, @next) = m(@next);
            let (@resp, m, @start) = m(@start);
            let (@req, m, @next) = m(@get);
            let (@req, m, @next) = m(@yield, '6');
            let (@req, m, @next) = m(@yield, '4');
            let (@req, m, @next) = m(@yield, '5');
            let (@resp, m, @ok, 645) = m(@eos);
            let (@req, m, @next) = m(@next);
            let (@resp, m, @start) = m(@start);
            let (@req, m, @next) = m(@get);
            let (@req, m, @next) = m(@yield, '1');
            let (@req, m, @next) = m(@yield, '2');
            let (@resp, m, @ok, 12) = m(@eos);
            let (@req, m, @next) = m(@next);
            let (@end, @eos) = m(@eos);

            let () = caller(@pass);
        }
    }

    proc run(caller, case_name) {
        R{ @cases this #get #get @exec }
    }
}

proc iter_to_sink(next, up, sink) {
    let (up) = up(@req, @next);
    match {
       // (@req) => {
       //     let (up) = up(@req);
       //     become this.iter_to_sink(next, up, iter, sink)
       // }
        (@yield, item) => {
            let (sink) = sink(@push, item);
            become this.iter_to_sink(next, up, sink)
        }
        (@eos) => {
            let () = sink(@finish);
            become next(up)
        }
    }
}


// Input     Output
// @next <-- @next
// @eos  --> @eos
// @start -> @start <transfer control to fn>
proc multi_iter_map(caller, constructor) {
    become caller(this.multi_iter_map_impl&(constructor))
}

proc multi_iter_map_impl(constructor, caller, @next) {
    let (caller) = req caller(@next);
    match {
        (@eos) => {
            become caller(@end, @eos)
        }
        (@start) => {
            let (caller) = resp caller(@start);
            let (constructor, fn) = constructor();
            let (caller) = this.fwd_to_end(caller, fn);
            let (caller) = resp caller();  // Forward the last message.
            become this.multi_iter_map_impl(constructor, caller)
        }
    }
}

proc fwd_to_end(next, up, down) {
    let () = down();
    match {
        (@req, down) => {
            let (up) = req up();
            become this.fwd_to_end(next, up, down)
        }
        (@resp, down) => {
            let (up) = resp up();
            become this.fwd_to_end(next, up, down)
        }
        (@end) => {
            become next(up)
        }
    }
}

proc sum_iter(acc, caller, @get) {
    let (caller) = caller&(@req);
    let (caller) = caller(@next);
}

proc parseint_list_of_str(caller, @next) {
    let (caller) = req caller(@next);
    match {
        (@start) => {
            let (p) = this.str.parseint_sink();
            let (caller, @ok, num) = this.iter_to_sink(caller, p);
            //let (caller, ^, @ok, num) = this.builtin.fwd_req(caller, p, @get);
            let (caller, @next) = resp caller(@yield, num);
            become this.parseint_list_of_str(caller, @next)
        }
        (@eos) => {
            let () = resp caller(@eos);
        }
    }
}

proc parseint_list_of_list_of_str(caller, @next) {
    let (caller) = req caller(@next);
    match {
        (@start) => {
            let (caller, @next) = resp caller(@start);
            let (p) = this.parseint_list_of_str;
            let (caller, ^, @eos) = this.fwd_yields(caller, p, @next);
            let (caller, @next) = resp caller(@eos);
            become this.parseint_list_of_list_of_str(caller, @next)
        }
        (@eos) => {
            let () = resp caller(@eos);
        }
    }
}

proc fwd_yields(next, up, down) {
    let (down) = down();
    match {
        (@req) => {
            let (up) = up(@req);
            become this.fwd_yields(next, up, down)
        }
        (@resp, @yield) => {
            let (up) = up(@resp, @yield);
            become this.fwd_yields(next, up, down)
        }
        (@resp, other) => {
            become next(up, down, other)
        }
    }
}

proc transpose2(caller, list) {
    become caller(this.transpose2_impl&(list))
}

proc transpose2_impl(list, caller, @next) {
    let (fronts) = this.list.new();
    let (rests) = this.list.new();
    let (fronts, rests) = this.take_first_row(fronts, rests, list);
    let (@resp, fronts, is_empty) = fronts(@is_empty);
    if is_empty {
        let () = resp caller(@eos);
    } else {
        let (caller, @next) = resp caller(@start);
        let (^@resp, , fronts) = fronts(@into_iter);
        let (caller, ^, @eos) = this.fwd_yields(caller, fronts, @next);
        let (caller, @next) = resp caller(@eos);
        become this.transpose2_impl(rests, caller, @next)
    }
}

proc take_first_row(caller, fronts, rests, list_of_lists) {
    let (@resp, list_of_lists) = list_of_lists(@pop_front);
    match {
        (@none) => {
            become caller(fronts, rests)
        }
        (@some, next_list) => {
            let (@resp, next_list) = next_list(@pop_front);
            match {
                (@none) => {
                    become this.take_first_row(caller, fronts, rests, list_of_lists)
                }
                (@some, item) => {
                    let (@resp, fronts) = fronts(@push_back, item);
                    let (@resp, rests) = rests(@push_back, next_list);
                    become this.take_first_row(caller, fronts, rests, list_of_lists)
                }
            }
        }
    }
}

proc abs_diff(caller, a, b) {
    let (lt) = this.builtin.lt(*a, *b);
    if lt {
        let (diff) = this.builtin.sub(b, a);
        become caller(diff)
    } else {
        let (diff) = this.builtin.sub(a, b);
        become caller(diff)
    }

}

proc iter_abs_diff(caller, @next) {
    let (caller) = req caller(@a, @next);
    match {
        (@eos) => {
            let () = resp caller(@eos);
        }
        (@yield, a) => {
            let (caller, @yield, b) = req caller(@b, @next);
            let (d) = this.abs_diff(a, b);
            let (caller, @next) = resp caller(@yield, d);
            become this.iter_abs_diff(caller, @next)
        }
    }    
}

proc reduce_sum(caller) {
    become caller(this.reduce_sum_impl&(0))
}

proc reduce_sum_impl(acc, caller, @get) {
    let (caller) = req caller(@next);
    match {
        (@eos) => {
            let () = resp caller(acc);
        }
        (@yield, item) => {
            let (acc) = this.builtin.add(acc, item);
            become this.reduce_sum_impl(acc, caller, @get)
        }
    }   
}

proc mat2dtolists(caller) {
    let (list) = this.list.new();
    become caller(this.mat2dtolists_impl&(list))
}

proc mat2dtolists_impl(list, caller, @get) {
    let (caller) = req caller(@next);
    match {
        (@start) => {
            let (collector) = this.iter_to_list();
            let (caller, ^, row) = this.builtin.fwd_req(caller, collector, @get);
            let (@resp, list) = list(@push_back, row);
            become this.mat2dtolists_impl(list, caller, @get)
        }
        (@eos) => {
            let () = resp caller(list);
        }
    }
}

proc iter_to_list(caller) {
    let (list) = this.list.new();
    become caller(this.iter_to_list_impl&(list))
}

proc iter_to_list_impl(list, caller, @get) {
    let (caller) = req caller(@next);
    match {
        (@eos) => {
            let () = resp caller(list);
        }
        (@yield, item) => {
            let (@resp, list) = list(@push_back, item);
            become this.iter_to_list_impl(list, caller, @get)
        }
    }
}

proc solve_the_thing(caller, @get) {
    let (ssv) = this.ssv.parser();
    let (numerical) = this.builtin.compose(ssv, this.parseint_list_of_list_of_str);
    let (as_lists) = this.mat2dtolists();
    let (as_lists) = this.builtin.compose(numerical, as_lists);
    let (caller, ^, as_lists) = this.builtin.fwd_req(caller, as_lists, @get);
    let (transposed) = this.transpose2(as_lists);

    let (as_lists) = this.mat2dtolists();
    let (as_lists) = this.builtin.compose(transposed, as_lists);
    let (^@resp, , as_lists) = as_lists(@get);

    let (@resp, as_lists, @some, a) = as_lists(@pop_front);
    let (@resp, as_lists, @some, b) = as_lists(@pop_front);
    let (@resp, as_lists, @none) = as_lists(@pop_front);

    let (^@resp, , a) = a(@into_iter);
    let (^@resp, , b) = b(@into_iter);

    let (a_sorted) = this.builtin.compose(a, this.iter.mergesort);
    let (b_sorted) = this.builtin.compose(b, this.iter.mergesort);

    let (c) = this.builtin.container_builder();
    let (c) = c(@bind, @a, a_sorted);
    let (c) = c(@bind, @b, b_sorted);
    let (c) = c(@build);

    let (diffs) = this.iter_abs_diff;
    let (diffs) = this.builtin.compose(c, diffs);

    let (sum) = this.reduce_sum();
    let (sum) = this.builtin.compose(diffs, sum);
    let (caller, ^, sum) = this.builtin.fwd_req(caller, sum, @get);

    let () = resp caller(sum);
}

proc main(caller) {
    let () = this.tests.cases.multi_iter_map_empty();

    let (sol) = this.builtin.compose(this.io.stdin_chars, this.solve_the_thing);
    let (caller, sol, num) = this.builtin.fwd_req(caller, sol, @get);
    
    let (caller) = req caller(@print, num);


    //let (ints) = this.builtin.bind(this.parseint_list_of_list_of_str, @iter, ssv);
//    
//    
//
//    let (mapped) = this.bind(this.iter.multi_map, @iter, ssv);
//
//    let (parseint) = this.parseint();
//
//    let (mapped) = this.bind(mapped, @reducer, parseint);
//
//    let () = mapped(@next);

//
   // let (ssv) = this.builtin.bind(this.dump, @iter, ints);
//
    //let (caller, ^, @eos) = this.builtin.fwd_req(caller, ssv, @get);
//
    let () = req caller(@halt);

    //let () = this.tests.cases.mergesort_full();
    //let (iter) = this.iter.symbol_chars&(@foobar);
    //let (^, @ok, aq, bq) = this.bind(this.iter.split, @iter, iter);
    //let (aq, @yield, 'f') = aq(@next);
    //let (aq, @yield, 'o') = aq(@next);
    //let (aq, @yield, 'a') = aq(@next);
    //let (aq, @eos) = aq(@next);
    //let (bq, @yield, 'o') = bq(@next);
    //let (bq, @yield, 'b') = bq(@next);
    //let (bq, @yield, 'r') = bq(@next);
    //let (bq, @eos) = bq(@next);
}