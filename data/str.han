use 'crate::builtin;

mod symbol { 
    mod iter {
        use 'crate::builtin;

        def new c#do [symbol => #iter{symbol, 0}]

        def next c#do [#iter{symbol, offset} => 
            (*offset, *symbol 'builtin::symbol_len) 'builtin::lt if {
                (#iter{*symbol, (*offset, 1) 'builtin::add}, #some{(symbol, offset) 'builtin::symbol_char_at})
            } else {
                (#iter{symbol, offset}, #none{})
            }
        ]

        // def _get_next match {
        //     #start{iter} => #cont{(), #next{iter}},
        //     #cont{(), resp} => #end{resp},
        // }

        // def stash1 match {
        //     #start{(a, b)} => (a, #start{b}) 'stash1_help,
        //     #cont{(a, b_state), b_resp} => (a, #cont{b_state, b_resp}) 'stash1_help,
        // }
        // def stash1_help [(a, b) => b '_get_next match {
        //     #end{b} => #end{(a, b)},
        //     #cont{b_state, b_req} => #cont{(a, b_state), b_req}
        // }]

        // def equals 
        //     c#first c#do [(iter, symbol) => ((symbol, 0), iter)]
        //     c#then 'stash1
        //     c#then c#do [((symbol, offset), (iter, finished)) => finished if {

        //     } else {
                
        //     }]
        // }
    }
}