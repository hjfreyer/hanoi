
proc new(caller) {
    become caller(this.list_empty)
}

proc list_empty(caller) {
    match {
        (@push_front, item) => {
            let (caller) = caller(@resp);
            become this.list_cons(item, this.list_empty, caller)
        }
        (@push_back, item) => {
            let (caller) = caller(@resp);
            become this.list_cons(item, this.list_empty, caller)
        }
        (@pop_front) => {
            let (caller) = caller(@resp, @none);
            become this.list_empty(caller)
        }
        (@into_iter) => {
            let (empty) = this.new();
            let () = caller(@resp, this.list_into_iter&(empty));
        }
        (@is_empty) => {
            let (caller) = caller(@resp, true);
            become this.list_empty(caller)
        }
    }
}

proc list_cons(head, tail, caller) {
    match {
        (@push_front, item) => {
            let (caller) = caller(@resp);
            let (tail) = this.list_cons&(head, tail);
            become this.list_cons(item, tail, caller)
        }
        (@push_back, item) => {
            let (tail, @resp) = tail(@push_back, item);
            let (caller) = caller(@resp);
            become this.list_cons(head, tail, caller)
        }
        (@pop_front) => {
            let (caller) = caller(@resp, @some, head);
            become tail(caller)
        }
        (@into_iter) => {
            let (self) = this.list_cons&(head, tail);
            let () = caller(@resp, this.list_into_iter&(self));
        }
        (@is_empty) => {
            let (caller) = caller(@resp, false);
            become this.list_cons(caller)
        }
    }
}

proc list_into_iter(list, caller) {
    let (list, @resp) = list(@pop_front);
    match {
        (@none) => {
            let (caller) = caller(@resp, @eos);
            become this.list_into_iter(list, caller)
        }
        (@some, item) => {
            let (caller) = caller(@resp, @yield, item);
            become this.list_into_iter(list, caller)
        }
    }
}

mod tests {
    proc enumerate(caller, @next) {
        let (caller, @next) = caller(@yield, @basic);
        let (caller, @next) = caller(@yield, @iter);
        let () = caller(@eos);        
    }

    mod cases {
        proc basic(caller) {
            let (q) = this.super.super.new();
            let (q, @resp) = q(@push_back, @foo);
            let (q, @resp) = q(@push_back, @bar);
            let (q, @resp) = q(@push_back, @baz);
            let (q, @resp, @some, @foo) = q(@pop_front);
            let (q, @resp, @some, @bar) = q(@pop_front);
            let (q, @resp, @some, @baz) = q(@pop_front);
            let (q, @resp, @none) = q(@pop_front);
            let () = caller(@pass);
        }

        proc iter(caller) {
            let (q) = this.super.super.new();
            let (q, @resp) = q(@push_back, @foo);
            let (q, @resp) = q(@push_back, @bar);
            let (q, @resp) = q(@push_back, @baz);
            let (^, @resp, i) = q(@into_iter);
            let (i, @resp, @yield, @foo) = i(@next);
            let (i, @resp, @yield, @bar) = i(@next);
            let (i, @resp, @yield, @baz) = i(@next);
            let (i, @resp, @eos) = i(@next);
            let () = caller(@pass);
        }
    }

    proc run(caller, case_name) {
        R{ @cases this #get #get @exec }
    }
}
