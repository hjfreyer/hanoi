
mod builtin;
mod iter;

mod tests {
    proc enumerate(caller, @next) {
        let (caller, @next) = caller(@yield, @empty_string);
        let (caller, @next) = caller(@yield, @basic_string);
        let () = caller(@eos);
    }

    mod cases {
        proc empty_string(caller) {
            let (p) = this.super.super.parser();
            let (@req, p, @next) = p(@next);
            let (@end, @eos) = p(@eos);

            let () = caller(@pass);
        }

        proc basic_string(caller) {
            let (input) = this.super.super.iter.symbol_chars(@"foo   bar
baz   qux
");

            let (p) = this.super.super.parser();
            let (p) = this.super.super.builtin.compose(input, p);
            let (@resp, p, @start) = p(@next);
            let (@resp, p, @start) = p(@next);
            let (@resp, p, @yield, 'f') = p(@next);
            let (@resp, p, @yield, 'o') = p(@next);
            let (@resp, p, @yield, 'o') = p(@next);
            let (@resp, p, @eos) = p(@next);
            let (@resp, p, @start) = p(@next);
            let (@resp, p, @yield, 'b') = p(@next);
            let (@resp, p, @yield, 'a') = p(@next);
            let (@resp, p, @yield, 'r') = p(@next);
            let (@resp, p, @eos) = p(@next);
            let (@resp, p, @eos) = p(@next);
            let (@resp, p, @start) = p(@next);
            let (@resp, p, @start) = p(@next);
            let (@resp, p, @yield, 'b') = p(@next);
            let (@resp, p, @yield, 'a') = p(@next);
            let (@resp, p, @yield, 'z') = p(@next);
            let (@resp, p, @eos) = p(@next);
            let (@resp, p, @start) = p(@next);
            let (@resp, p, @yield, 'q') = p(@next);
            let (@resp, p, @yield, 'u') = p(@next);
            let (@resp, p, @yield, 'x') = p(@next);
            let (@resp, p, @eos) = p(@next);
            let (@resp, p, @eos) = p(@next);
            let (@end, @eos) = p(@next);

            let () = caller(@pass);
        }
    }

    proc run(caller, case_name) {
        R{ @cases this #get #get @exec }
    }
}

proc parser(caller) {
    become caller(this.impl_start)
}

proc impl_start(caller, @next) {
    become this.impl_newline(caller, @next)
}

proc impl_newline(caller, @next) {
    let (caller) = req caller(@next);
    match {
        (@eos) => {
            become caller(@end, @eos)
        }
        (@yield, ' ') => {
            let () = resp caller(@err, @unexpected_space);
        }
        (@yield, char) => {
            let (caller, @next) = resp caller(@start);
            let (caller, @next) = resp caller(@start);
            let (caller, @next) = resp caller(@yield, char);
            
            become this.impl_infield(caller, @next)
        }
    }
}

proc impl_infield(caller, @next) {
    let (caller) = req caller(@next);
    match {
        (@eos) => {
            let () = resp caller(@err, @unexpected_eos);
        }
        (@yield, ' ') => {
            let (caller, @next) = resp caller(@eos);
            become this.impl_inspace(caller, @next)
        } 
        (@yield, '\n') => {
            let (caller, @next) = resp caller(@eos);
            let (caller, @next) = resp caller(@eos);
            become this.impl_newline(caller, @next)
        } 
        (@yield, char) => {
            let (caller, @next) = resp caller(@yield, char);
            become this.impl_infield(caller, @next)
        }
    }
}

proc impl_inspace(caller, @next) {
    let (caller) = req caller(@next);
    match {
        (@eos) => {
            let () = resp caller(@err, @unexpected_eos);
        }
        (@yield, '\n') => {
            let () = resp caller(@err, @unexpected_eol);
        }
        (@yield, ' ') => {
            become this.impl_inspace(caller, @next)
        }
        (@yield, char) => {
            let (caller, @next) = resp caller(@start);
            let (caller, @next) = resp caller(@yield, char);
            become this.impl_infield(caller, @next)
        }
    }
}