
//mod builtin;
//mod io;
//mod ssv;
//mod iter;
//mod list;
//mod str;
//mod adv1p1;
//mod multi_iter;
//

sentence test {
    #call('tests::main)
}

mod tests {
    proc args main => args match {
        (#nil{}, #enumerate{}) => (#nil{}, #a{}),
        (#a{}, #next{}) => (#b{}, #some{@parse_empty}),
        (#b{}, #next{}) => (#c{}, #some{@parse_some}),
        (#c{}, #next{}) => (#d{}, #none{}),

        (#nil{}, #run{@parse_empty}) => () 'cases::parse_empty,
        (#nil{}, #run{@parse_some}) => () 'cases::parse_some,
    }

    mod cases {
        proc () parse_empty => {
            let (p, #req{#next{}}) = (#nil{}, #parse{}) 'super::super::parseint;
            let (^, #resp{0}) = (p, #none{}) 'super::super::parseint;
            ()
        }

        proc () parse_some => {
            let (p, #req{#next{}}) = (#nil{}, #parse{}) 'super::super::parseint;
            let (p, #req{#next{}}) = (p, #some{'6'}) 'super::super::parseint;
            let (p, #req{#next{}}) = (p, #some{'7'}) 'super::super::parseint;
            let (p, #req{#next{}}) = (p, #some{'2'}) 'super::super::parseint;
            let (^, #resp{672}) = (p, #none{}) 'super::super::parseint;
            ()
        }
    }
}

sentence ord {
    #ord
}

sentence prod {
    #untuple(2) #prod
}

sentence sub {
    #untuple(2) #sub
}


proc (self, method) parseint => {
    self match {
        #nil{} => {
            let #parse{} = method;
            (#await_next{0}, #req{#next{}})
        },
        #await_next{acc} => {
            method match {
                #none{} => (#done{}, #resp{acc}),
                #some{c} => {
                    let digit = (c 'ord, 48) 'sub;
                    let acc = ((10, acc) 'prod, digit) 'add;
                    (#await_next{acc}, #req{#next{}})
                },
            }
        },
    }
}

sentence add {
    #untuple(2) #add
}

sentence eq {
    #untuple(2) #eq
}

proc x double => {
    (*x, x) 'add
}

mod ints {
    proc () alloc => {
        (@start, 0)
    }

    proc ((@start, s), @next) main => {
        let ^ = 3;
        let res = (@some, *s);
        ((@start, (s, 1) 'super::add), res)
    }
}

proc () main_impl => {
    // let m = () 'map::alloc;
    // let (m, (@iter, (@next, ()))) = (m, (@next, ())) 'map::main;
    // let (m, (@fn, (@apply, 3))) = (m, (@some, 3)) 'map::main;
    // let (m, (@res, (@some, 6))) = (m, 6) 'map::main;
    // let (m, (@iter, (@next, ()))) = (m, (@next, ())) 'map::main;
    // let (m, (@fn, (@apply, 7))) = (m, (@some, 7)) 'map::main;
    // let (m, (@res, (@some, 14))) = (m, 14) 'map::main;
    // let (m, (@iter, (@next, ()))) = (m, (@next, ())) 'map::main;
    // let (^, (@res, (@none, ()))) = (m, (@none, ())) 'map::main;

    let ((@nil, ()), test_iter) = ((@nil, ()), (@enumerate, ())) 'tests::main;
    let (test_iter, (@some, @parse_empty)) = (test_iter, (@next, ())) 'tests::main;
    let ^ = test_iter;

    ()
}

sentence main {
    #tuple(0) #call('main_impl)
}

