
mod builtin;
mod io;
mod ssv;
mod iter;
mod str;

mod tests {
    proc enumerate(caller, @next) {
//        let (caller, @next) = caller(@yield, @basic_csv);
        let (caller, @next) = caller(@yield, @parseint_list_of_str);
        let (caller, @next) = caller(@yield, @parseint_list_of_list_of_str);
        let () = caller(@eos);        
    }

    mod cases {
        proc basic_csv(caller) {
            let (iter) = this.super.super.iter.symbol_chars(@"foo,bar
baz");
            let (bound) = this.super.super.builtin.bind(
                this.super.super.csv.start, 
                @iter, 
                iter);

            let (bound, @resp, @startrow) = bound(@next);
            let (bound, @resp, @startfield) = bound(@next);
            let (bound, @resp, @yield, 'f') = bound(@next);
            let (bound, @resp, @yield, 'o') = bound(@next);
            let (bound, @resp, @yield, 'o') = bound(@next);
            let (bound, @resp, @endfield) = bound(@next);
            let (bound, @resp, @startfield) = bound(@next);
            let (bound, @resp, @yield, 'b') = bound(@next);
            let (bound, @resp, @yield, 'a') = bound(@next);
            let (bound, @resp, @yield, 'r') = bound(@next);
            let (bound, @resp, @endfield) = bound(@next);
            let (bound, @resp, @endrow) = bound(@next);
            let (bound, @resp, @startrow) = bound(@next);
            let (bound, @resp, @startfield) = bound(@next);
            let (bound, @resp, @yield, 'b') = bound(@next);
            let (bound, @resp, @yield, 'a') = bound(@next);
            let (bound, @resp, @yield, 'z') = bound(@next);
            let (bound, @resp, @endfield) = bound(@next);
            let (bound, @resp, @endrow) = bound(@next);
            let (bound, @resp, @eos) = bound(@next);
            let () = caller(@pass);
        }

        proc parseint_list_of_str(caller) {
            let (p) = this.super.super.parseint_list_of_str;

            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '1');
            let (p, @req, @iter, @next) = p(@yield, '2');
            let (p, @req, @iter, @next) = p(@yield, '3');
            let (p, @resp, @yield, 123) = p(@eos);
            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '4');
            let (p, @req, @iter, @next) = p(@yield, '5');
            let (p, @req, @iter, @next) = p(@yield, '6');
            let (p, @resp, @yield, 456) = p(@eos);
            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @eos) = p(@eos);
            
            let () = caller(@pass);
        }

        proc parseint_list_of_list_of_str(caller) {
            let (p) = this.super.super.parseint_list_of_list_of_str;

            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @start) = p(@start);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '1');
            let (p, @req, @iter, @next) = p(@yield, '2');
            let (p, @req, @iter, @next) = p(@yield, '3');
            let (p, @resp, @yield, 123) = p(@eos);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '4');
            let (p, @req, @iter, @next) = p(@yield, '5');
            let (p, @req, @iter, @next) = p(@yield, '6');
            let (p, @resp, @yield, 456) = p(@eos);
            
            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @eos) = p(@eos);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @start) = p(@start);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '1');
            let (p, @req, @iter, @next) = p(@yield, '2');
            let (p, @req, @iter, @next) = p(@yield, '3');
            let (p, @resp, @yield, 123) = p(@eos);
            
            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @eos) = p(@eos);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @eos) = p(@eos);
            
            let () = caller(@pass);
        }
    }

    proc run(caller, case_name) {
        R{ @cases this #get #get @exec }
    }
}

mod csv {
    proc start(caller, @next) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) =>  {
                let () = caller(@resp, @eos);
            }
            (@yield, char) => {
                let (caller, @next) = caller(@resp, @startrow);
                let (caller) = caller(@resp, @startfield);
                become this.default_handle_char(caller, char)
            }
        }
    }

    proc default_handle_char(caller) {
        match {
            ('\n') => {
                let (caller, @next) = caller(@resp, @endfield);
                let () = caller(@resp, @endrow);
                become this.start()
            }
            ('"') => {
                become this.quoted(caller)
            }
            ('\\') => {
                become this.escaped(caller)
            }
            (',') => {
                let (caller, @next) = caller(@resp, @endfield);
                let () = caller(@resp, @startfield);
                become this.non_quoted()               
            }
            (char) => {
                let () = caller(@resp, @yield, char);
                become this.non_quoted()
            }
        }
    }

    proc non_quoted(caller) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) => {
                let (caller, @next) = caller(@resp, @endfield);
                let (caller, @next) = caller(@resp, @endrow);
                let () = caller(@resp, @eos);
            }
            (@yield, char) => {
                become this.default_handle_char(caller, char)
            }
        }
    }

    proc quoted(caller) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) => {
                let () = caller(@resp, @err, @nonterminatedquote);
            }
            (@yield, '"') => {
                become this.non_quoted(caller)
            }
            (@yield, char) => {
                let (caller, @next) = caller(@resp);
                become this.default_handle_char(caller, char)
            }
        }
    }
}

proc dump(caller, @get) {
    let (caller) = caller(@req, @iter, @next);
    match {
        (@eos) => {
            let (caller) = caller(@req, @print, @eos);
            become this.dump(caller, @get)
        }
        (@start) => {
            let (caller) = caller(@req, @print, @start);
            become this.dump(caller, @get)
        }
        (@end) => {
            let (caller) = caller(@req, @print, @end);
            become this.dump(caller, @get)
        }
        (@yield, item) => {
            let (caller) = caller(@req, @print, item);
            become this.dump(caller, @get)
        }
    }
}

proc parseint_list_of_str(caller, @next) {
    let (caller) = caller(@req, @iter, @next);
    match {
        (@start) => {
            let (p) = this.str.parseint();
            let (caller, ^, @ok, num) = this.builtin.fwd_req(caller, p, @get);
            let (caller, @next) = caller(@resp, @yield, num);
            become this.parseint_list_of_str(caller, @next)
        }
        (@eos) => {
            let () = caller(@resp, @eos);
        }
    }
}

proc parseint_list_of_list_of_str(caller, @next) {
    let (caller) = caller(@req, @iter, @next);
    match {
        (@start) => {
            let (caller, @next) = caller(@resp, @start);
            let (p) = this.parseint_list_of_str;
            let (caller, ^, @eos) = this.fwd_yields(caller, p, @next);
            let (caller, @next) = caller(@resp, @eos);
            become this.parseint_list_of_list_of_str(caller, @next)
        }
        (@eos) => {
            let () = caller(@resp, @eos);
        }
    }
}

proc fwd_yields(next, up, down) {
    let (down) = down();
    match {
        (@req) => {
            let (up) = up(@req);
            become this.fwd_yields(next, up, down)
        }
        (@resp, @yield) => {
            let (up) = up(@resp, @yield);
            become this.fwd_yields(next, up, down)
        }
        (@resp, other) => {
            become next(up, down, other)
        }
    }
}

proc main(caller) {
    let (ssv) = this.builtin.bind(this.ssv.impl_start, @source, this.io.stdin_chars);

    let (ints) = this.builtin.bind(this.parseint_list_of_list_of_str, @iter, ssv);
//    
//    let (caller, ssv, @start) = this.fwd_req(caller, ssv, @next);
//
//    let (mapped) = this.bind(this.iter.multi_map, @iter, ssv);
//
//    let (parseint) = this.parseint();
//
//    let (mapped) = this.bind(mapped, @reducer, parseint);
//
//    let () = mapped(@next);

//
    let (ssv) = this.builtin.bind(this.dump, @iter, ints);
//
    let (caller, ^, @eos) = this.builtin.fwd_req(caller, ssv, @get);
//
    ///let () = caller(@req, @halt);

    //let () = this.tests.cases.mergesort_full();
    //let (iter) = this.iter.symbol_chars&(@foobar);
    //let (^, @ok, aq, bq) = this.bind(this.iter.split, @iter, iter);
    //let (aq, @yield, 'f') = aq(@next);
    //let (aq, @yield, 'o') = aq(@next);
    //let (aq, @yield, 'a') = aq(@next);
    //let (aq, @eos) = aq(@next);
    //let (bq, @yield, 'o') = bq(@next);
    //let (bq, @yield, 'b') = bq(@next);
    //let (bq, @yield, 'r') = bq(@next);
    //let (bq, @eos) = bq(@next);
}