
mod builtin;
mod io;
mod ssv;
mod iter;
mod list;
mod str;

mod tests {
    proc enumerate(caller, @next) {
//        let (caller, @next) = caller(@yield, @basic_csv);
        let (caller, @next) = caller(@yield, @parseint_list_of_str);
        let (caller, @next) = caller(@yield, @parseint_list_of_list_of_str);
        let (caller, @next) = caller(@yield, @transpose2_empty);
        let (caller, @next) = caller(@yield, @transpose2_single_row);
        let (caller, @next) = caller(@yield, @transpose2_single_col);
        let (caller, @next) = caller(@yield, @transpose2_full);
        let () = caller(@eos);        
    }

    mod cases {
        proc basic_csv(caller) {
            let (iter) = this.super.super.iter.symbol_chars(@"foo,bar
baz");
            let (bound) = this.super.super.builtin.bind(
                this.super.super.csv.start, 
                @iter, 
                iter);

            let (bound, @resp, @startrow) = bound(@next);
            let (bound, @resp, @startfield) = bound(@next);
            let (bound, @resp, @yield, 'f') = bound(@next);
            let (bound, @resp, @yield, 'o') = bound(@next);
            let (bound, @resp, @yield, 'o') = bound(@next);
            let (bound, @resp, @endfield) = bound(@next);
            let (bound, @resp, @startfield) = bound(@next);
            let (bound, @resp, @yield, 'b') = bound(@next);
            let (bound, @resp, @yield, 'a') = bound(@next);
            let (bound, @resp, @yield, 'r') = bound(@next);
            let (bound, @resp, @endfield) = bound(@next);
            let (bound, @resp, @endrow) = bound(@next);
            let (bound, @resp, @startrow) = bound(@next);
            let (bound, @resp, @startfield) = bound(@next);
            let (bound, @resp, @yield, 'b') = bound(@next);
            let (bound, @resp, @yield, 'a') = bound(@next);
            let (bound, @resp, @yield, 'z') = bound(@next);
            let (bound, @resp, @endfield) = bound(@next);
            let (bound, @resp, @endrow) = bound(@next);
            let (bound, @resp, @eos) = bound(@next);
            let () = caller(@pass);
        }

        proc parseint_list_of_str(caller) {
            let (p) = this.super.super.parseint_list_of_str;

            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '1');
            let (p, @req, @iter, @next) = p(@yield, '2');
            let (p, @req, @iter, @next) = p(@yield, '3');
            let (p, @resp, @yield, 123) = p(@eos);
            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '4');
            let (p, @req, @iter, @next) = p(@yield, '5');
            let (p, @req, @iter, @next) = p(@yield, '6');
            let (p, @resp, @yield, 456) = p(@eos);
            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @eos) = p(@eos);
            
            let () = caller(@pass);
        }

        proc parseint_list_of_list_of_str(caller) {
            let (p) = this.super.super.parseint_list_of_list_of_str;

            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @start) = p(@start);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '1');
            let (p, @req, @iter, @next) = p(@yield, '2');
            let (p, @req, @iter, @next) = p(@yield, '3');
            let (p, @resp, @yield, 123) = p(@eos);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '4');
            let (p, @req, @iter, @next) = p(@yield, '5');
            let (p, @req, @iter, @next) = p(@yield, '6');
            let (p, @resp, @yield, 456) = p(@eos);
            
            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @eos) = p(@eos);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @start) = p(@start);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @req, @iter, @next) = p(@start);
            let (p, @req, @iter, @next) = p(@yield, '1');
            let (p, @req, @iter, @next) = p(@yield, '2');
            let (p, @req, @iter, @next) = p(@yield, '3');
            let (p, @resp, @yield, 123) = p(@eos);
            
            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @eos) = p(@eos);

            let (p, @req, @iter, @next) = p(@next);
            let (p, @resp, @eos) = p(@eos);
            
            let () = caller(@pass);
        }
        
        proc transpose2_empty(caller) {
            let (list) = this.super.super.list.new();

            let (t) = this.super.super.transpose2(list);
            let (t, @resp, @eos) = t(@next);

            let () = caller(@pass);
        }

        proc transpose2_single_row(caller) {
            let (row) = this.super.super.list.new();
            let (row, @resp) = row(@push_back, @foo);
            let (row, @resp) = row(@push_back, @bar);
            let (row, @resp) = row(@push_back, @baz);

            let (list) = this.super.super.list.new();
            let (list, @resp) = list(@push_back, row);

            let (t) = this.super.super.transpose2(list);
            let (t, @resp, @start) = t(@next);
            let (t, @resp, @yield, @foo) = t(@next);
            let (t, @resp, @eos) = t(@next);
            let (t, @resp, @start) = t(@next);
            let (t, @resp, @yield, @bar) = t(@next);
            let (t, @resp, @eos) = t(@next);
            let (t, @resp, @start) = t(@next);
            let (t, @resp, @yield, @baz) = t(@next);
            let (t, @resp, @eos) = t(@next);
            let (t, @resp, @eos) = t(@next);
            
            let () = caller(@pass);
        }

        proc transpose2_single_col(caller) {
            let (list) = this.super.super.list.new();

            let (row) = this.super.super.list.new();
            let (row, @resp) = row(@push_back, @foo);
            let (list, @resp) = list(@push_back, row);
            
            let (row) = this.super.super.list.new();
            let (row, @resp) = row(@push_back, @bar);
            let (list, @resp) = list(@push_back, row);
            
            let (row) = this.super.super.list.new();
            let (row, @resp) = row(@push_back, @baz);
            let (list, @resp) = list(@push_back, row);

            let (t) = this.super.super.transpose2(list);
            let (t, @resp, @start) = t(@next);
            let (t, @resp, @yield, @foo) = t(@next);
            let (t, @resp, @yield, @bar) = t(@next);
            let (t, @resp, @yield, @baz) = t(@next);
            let (t, @resp, @eos) = t(@next);
            let (t, @resp, @eos) = t(@next);
            
            let () = caller(@pass);
        }

        proc transpose2_full(caller) {
            let (list) = this.super.super.list.new();

            let (row) = this.super.super.list.new();
            let (row, @resp) = row(@push_back, @foo);
            let (row, @resp) = row(@push_back, @bar);
            let (list, @resp) = list(@push_back, row);
            
            let (row) = this.super.super.list.new();
            let (row, @resp) = row(@push_back, @baz);
            let (row, @resp) = row(@push_back, @qux);
            let (list, @resp) = list(@push_back, row);
            
            let (row) = this.super.super.list.new();
            let (row, @resp) = row(@push_back, 1);
            let (row, @resp) = row(@push_back, 2);
            let (list, @resp) = list(@push_back, row);

            let (t) = this.super.super.transpose2(list);
            let (t, @resp, @start) = t(@next);
            let (t, @resp, @yield, @foo) = t(@next);
            let (t, @resp, @yield, @baz) = t(@next);
            let (t, @resp, @yield, 1) = t(@next);
            let (t, @resp, @eos) = t(@next);
            let (t, @resp, @start) = t(@next);
            let (t, @resp, @yield, @bar) = t(@next);
            let (t, @resp, @yield, @qux) = t(@next);
            let (t, @resp, @yield, 2) = t(@next);
            let (t, @resp, @eos) = t(@next);
            let (t, @resp, @eos) = t(@next);
            
            let () = caller(@pass);
        }
    }

    proc run(caller, case_name) {
        R{ @cases this #get #get @exec }
    }
}

mod csv {
    proc start(caller, @next) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) =>  {
                let () = caller(@resp, @eos);
            }
            (@yield, char) => {
                let (caller, @next) = caller(@resp, @startrow);
                let (caller) = caller(@resp, @startfield);
                become this.default_handle_char(caller, char)
            }
        }
    }

    proc default_handle_char(caller) {
        match {
            ('\n') => {
                let (caller, @next) = caller(@resp, @endfield);
                let () = caller(@resp, @endrow);
                become this.start()
            }
            ('"') => {
                become this.quoted(caller)
            }
            ('\\') => {
                become this.escaped(caller)
            }
            (',') => {
                let (caller, @next) = caller(@resp, @endfield);
                let () = caller(@resp, @startfield);
                become this.non_quoted()               
            }
            (char) => {
                let () = caller(@resp, @yield, char);
                become this.non_quoted()
            }
        }
    }

    proc non_quoted(caller) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) => {
                let (caller, @next) = caller(@resp, @endfield);
                let (caller, @next) = caller(@resp, @endrow);
                let () = caller(@resp, @eos);
            }
            (@yield, char) => {
                become this.default_handle_char(caller, char)
            }
        }
    }

    proc quoted(caller) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) => {
                let () = caller(@resp, @err, @nonterminatedquote);
            }
            (@yield, '"') => {
                become this.non_quoted(caller)
            }
            (@yield, char) => {
                let (caller, @next) = caller(@resp);
                become this.default_handle_char(caller, char)
            }
        }
    }
}

proc dump(caller, @get) {
    let (caller) = caller(@req, @iter, @next);
    match {
        (@eos) => {
            let (caller) = caller(@req, @print, @eos);
            become this.dump(caller, @get)
        }
        (@start) => {
            let (caller) = caller(@req, @print, @start);
            become this.dump(caller, @get)
        }
        (@end) => {
            let (caller) = caller(@req, @print, @end);
            become this.dump(caller, @get)
        }
        (@yield, item) => {
            let (caller) = caller(@req, @print, item);
            become this.dump(caller, @get)
        }
    }
}

proc parseint_list_of_str(caller, @next) {
    let (caller) = caller(@req, @iter, @next);
    match {
        (@start) => {
            let (p) = this.str.parseint();
            let (caller, ^, @ok, num) = this.builtin.fwd_req(caller, p, @get);
            let (caller, @next) = caller(@resp, @yield, num);
            become this.parseint_list_of_str(caller, @next)
        }
        (@eos) => {
            let () = caller(@resp, @eos);
        }
    }
}

proc parseint_list_of_list_of_str(caller, @next) {
    let (caller) = caller(@req, @iter, @next);
    match {
        (@start) => {
            let (caller, @next) = caller(@resp, @start);
            let (p) = this.parseint_list_of_str;
            let (caller, ^, @eos) = this.fwd_yields(caller, p, @next);
            let (caller, @next) = caller(@resp, @eos);
            become this.parseint_list_of_list_of_str(caller, @next)
        }
        (@eos) => {
            let () = caller(@resp, @eos);
        }
    }
}

proc fwd_yields(next, up, down) {
    let (down) = down();
    match {
        (@req) => {
            let (up) = up(@req);
            become this.fwd_yields(next, up, down)
        }
        (@resp, @yield) => {
            let (up) = up(@resp, @yield);
            become this.fwd_yields(next, up, down)
        }
        (@resp, other) => {
            become next(up, down, other)
        }
    }
}

proc transpose2(caller, list) {
    become caller(this.transpose2_impl&(list))
}

proc transpose2_impl(list, caller, @next) {
    let (fronts) = this.list.new();
    let (rests) = this.list.new();
    let (fronts, rests) = this.take_first_row(fronts, rests, list);
    let (fronts, @resp, is_empty) = fronts(@is_empty);
    if is_empty {
        let () = caller(@resp, @eos);
    } else {
        let (caller, @next) = caller(@resp, @start);
        let (^, @resp, fronts) = fronts(@into_iter);
        let (caller, ^, @eos) = this.fwd_yields(caller, fronts);
        let (caller, @next) = caller(@resp, @eos);
        become this.transpose2_impl(rests, caller, @next)
    }
}

proc take_first_row(caller, fronts, rests, list_of_lists) {
    let (list_of_lists, @resp) = list_of_lists(@pop_front);
    match {
        (@none) => {
            become caller(fronts, rests)
        }
        (@some, next_list) => {
            let (next_list, @resp) = next_list(@pop_front);
            match {
                (@none) => {
                    become this.take_first_row(caller, fronts, rests, list_of_lists)
                }
                (@some, item) => {
                    let (fronts, @resp) = fronts(@push_back, item);
                    let (rests, @resp) = rests(@push_back, next_list);
                    become this.take_first_row(caller, fronts, rests, list_of_lists)
                }
            }
        }
    }
}

proc main(caller) {
    let () = this.tests.cases.transpose2_single_row();

    //let (ssv) = this.builtin.bind(this.ssv.impl_start, @source, this.io.stdin_chars);

    //let (ints) = this.builtin.bind(this.parseint_list_of_list_of_str, @iter, ssv);
//    
//    let (caller, ssv, @start) = this.fwd_req(caller, ssv, @next);
//
//    let (mapped) = this.bind(this.iter.multi_map, @iter, ssv);
//
//    let (parseint) = this.parseint();
//
//    let (mapped) = this.bind(mapped, @reducer, parseint);
//
//    let () = mapped(@next);

//
   // let (ssv) = this.builtin.bind(this.dump, @iter, ints);
//
    //let (caller, ^, @eos) = this.builtin.fwd_req(caller, ssv, @get);
//
    ///let () = caller(@req, @halt);

    //let () = this.tests.cases.mergesort_full();
    //let (iter) = this.iter.symbol_chars&(@foobar);
    //let (^, @ok, aq, bq) = this.bind(this.iter.split, @iter, iter);
    //let (aq, @yield, 'f') = aq(@next);
    //let (aq, @yield, 'o') = aq(@next);
    //let (aq, @yield, 'a') = aq(@next);
    //let (aq, @eos) = aq(@next);
    //let (bq, @yield, 'o') = bq(@next);
    //let (bq, @yield, 'b') = bq(@next);
    //let (bq, @yield, 'r') = bq(@next);
    //let (bq, @eos) = bq(@next);
}