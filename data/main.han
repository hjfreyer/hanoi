
mod builtin;

mod tests {
    proc enumerate(caller, @next) {
        let (caller, @next) = caller(@yield, @assert_true);
        let (caller, @next) = caller(@yield, @symbol_len);
        let (caller, @next) = caller(@yield, @symbol_iter);
        let (caller, @next) = caller(@yield, @basic_csv);
            // let (caller, @next) = caller(@yield, @manually_drive_map);
        let () = caller(@eos);        
    }

    mod cases {
        proc assert_true(caller) {
            let () = caller(@pass);
        }

        proc symbol_len(caller) {
            let (_, @ok, 3) = this.super.super.builtin.symbol_len(@foo);
            let () = caller(@pass);
        }

        proc basic_csv(caller) {
            let (iter) = this.super.super.iter.symbol_chars&(@"foo,bar
baz");
            let (bound) = this.super.super.iter.do_bind_iter&(
                this.super.super.csv.start, 
                @iter, 
                iter);

            let (bound, @startrow) = bound();
            let (bound, @startfield) = bound();
            let (bound, @yield, 'f') = bound();
            let (bound, @yield, 'o') = bound();
            let (bound, @yield, 'o') = bound();
            let (bound, @endfield) = bound();
            let (bound, @startfield) = bound();
            let (bound, @yield, 'b') = bound();
            let (bound, @yield, 'a') = bound();
            let (bound, @yield, 'r') = bound();
            let (bound, @endfield) = bound();
            let (bound, @endrow) = bound();
            let (bound, @startrow) = bound();
            let (bound, @startfield) = bound();
            let (bound, @yield, 'b') = bound();
            let (bound, @yield, 'a') = bound();
            let (bound, @yield, 'z') = bound();
            let (bound, @endfield) = bound();
            let (bound, @endrow) = bound();
            let (bound, @eos) = bound();
            let () = caller(@pass);
        }

        proc symbol_iter(caller) {
            let (iter) = this.super.super.iter.symbol_chars&(@foo);
            let (cont, @yield, 'f') = iter(@next);
            let (cont, @yield, 'o') = cont(@next);
            let (cont, @yield, 'o') = cont(@next);
            let (cont, @eos) = cont(@next);
            let () = caller(@pass);
        }
    }

    proc run(caller, case_name) {
        R{ @cases this #get #get @exec }
    }
}

mod csv {
    proc start(caller) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) =>  {
                let () = caller(@eos);
            }
            (@yield, char) => {
                let (caller) = caller(@startrow);
                let (caller) = caller(@startfield);
                become this.default_handle_char(caller, char)
            }
        }
    }

    proc default_handle_char(caller) {
        match {
            ('\n') => {
                let (caller) = caller(@endfield);
                let (caller) = caller(@endrow);
                become this.start(caller)
            }
            ('"') => {
                become this.quoted(caller)
            }
            ('\\') => {
                become this.escaped(caller)
            }
            (',') => {
                let (caller) = caller(@endfield);
                let (caller) = caller(@startfield);
                become this.non_quoted(caller)               
            }
            (char) => {
                let (caller) = caller(@yield, char);
                become this.non_quoted(caller)
            }
        }
    }

    proc non_quoted(caller) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) => {
                let (caller) = caller(@endfield);
                let (caller) = caller(@endrow);
                let () = caller(@eos);
            }
            (@yield, char) => {
                become this.default_handle_char(caller, char)
            }
        }
    }

    proc quoted(caller) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) => {
                let () = caller(@err, @nonterminatedquote);
            }
            (@yield, '"') => {
                become this.non_quoted(caller)
            }
            (@yield, char) => {
                let (caller) = caller();
                become this.default_handle_char(caller, char)
            }
        }
    }
}

mod iter {
    proc symbol_chars_inner(symbol, offset, caller, @next) {
        let (^, @ok, len) = this.super.builtin.symbol_len(*symbol);
        let (^, @ok, are_eq) = this.super.builtin.eq(*offset, len);
        if are_eq {
            let () = caller(@eos);
        } else {
            let (^, @ok, char) = this.super.builtin.symbol_char_at(*symbol, *offset);
            let (^, @ok, offset) = this.super.builtin.add(offset, 1);
            let () = caller(@yield, char);
            become this.symbol_chars_inner(symbol, offset)
        }
    }

    proc symbol_chars(symbol) {
        become this.symbol_chars_inner(symbol, 0)
    }

    proc map(caller, @next) {
        let (caller) = caller(@request, @iter, @next);
        match {
            (@eos) => {
                let () = caller(@eos);
            }
            (@yield, item) => {
                let (caller) = caller(@request, @fn, item);
                match {
                    (@ok, applied) => {
                        let () = caller(@yield, applied);
                        become this.map()
                    }
                }
            }
        }
    }

    proc do_bind_iter(inner, symbol, iter, caller) {
        let (inner) = inner();
        match {
            (@req, name) =>  {
                let (^, @ok, are_eq) = this.super.builtin.eq(*name, *symbol);
                if are_eq {
                    let (iter) = iter();
                    become this.do_bind_iter(inner, symbol, iter, caller)
                } else {
                    let (caller) = caller(@req, name);
                    become this.do_bind_iter(inner, symbol, iter, caller)
                }
            }
            (tag) => {
                let (caller) = caller(tag);
                become this.do_bind_iter(inner, symbol, iter, caller)
                
            }
        }
    }

    proc split(caller) {
        let (caller) = caller(@req, @iter, @next);
        match {
            (@eos) => {
                let () = caller(@ok, this.super.queue_empty, this.super.queue_empty);
            }
            (@yield, a) => {
                let (caller, ^, aq, bq) = this.until_ok(caller, this.split);
                let (bq) = bq(@push_back, a);
                let (caller) = caller(@ok, bq, aq);
            }
        }
    }

    proc until_ok(next, up, down) {
        let (down) = down();
        match {
            (@ok) => {
                become next(up, down)
            }
            (tag) => {
                let (up) = up(tag);
                become this.until_ok(next, up, down)
            }
        }
    }

   // proc merge(caller) {
//
   // }
//
   // proc mergesort(caller) {
   //     let (evens, odds) =  split();
   //     let (evens) = mergesort(evens);
   //     let (odds) = mergesort(odds);
   //     become merge(evens, odds)
   // }
}

proc queue_empty(caller) {
    match {
        (@push_back, item) => {
            let (caller) = caller();
            become this.queue_cons(item, this.queue_empty, caller)
        }
        (@next) => {
            let (caller) = caller(@eos);
            become this.queue_empty(caller)
        }
    }
}

proc queue_cons(head, tail, caller) {
    match {
        (@push_back, item) => {
            let (tail) = tail(@push_back, item);
            let (caller) = caller();
            become this.queue_cons(head, tail, caller)
        }
        (@next) => {
            let (caller) = caller(@yield, head);
            become tail(caller)
        }
    }
}

proc list_empty(caller) {
    R{
        [caller]
        @nil caller @exec
    }
}


proc list_append(caller, head, tail) {
    R{
        [tail, head, caller]
        tail head #cons @cons #cons caller @exec
    }
}

proc list_snoc(caller, list) {
    let () = this.list_snoc(list);
    match {
        (@nil) => {
            become caller(@nil)
        }
        (@cons, t) => {
            let (h, t) = this.list_snoc(t);
            become caller(@cons, h, t)
        }
    }
}

proc list_sorted_merge(caller, a, b) {

}


proc bind(caller, inner, symbol, target) {
    let (inner) = inner();
    match {
        (@req, name) =>  {
            let (^, @ok, are_eq) = this.builtin.eq(*name, *symbol);
            if are_eq {
                let (target) = target();
                become this.bind(caller, inner, symbol, target )
            } else {
                let (caller) = caller(@req, name);
                become this.bind(caller, inner, symbol, target)
            }
        }
        (tag) => {
            let (caller) = caller(tag);
            become this.bind(caller, inner, symbol, target)
        }
    }
}


proc main() {
    let (iter) = this.iter.symbol_chars&(@foobar);
    let (^, @ok, aq, bq) = this.bind(this.iter.split, @iter, iter);
    let (aq, @yield, @f) = aq(@next);
    let (aq, @yield, @o) = aq(@next);
    let (aq, @yield, @a) = aq(@next);
    let (aq, @eos) = aq(@next);
    let (bq, @yield, @o) = bq(@next);
    let (bq, @yield, @b) = bq(@next);
    let (bq, @yield, @r) = bq(@next);
    let (bq, @eos) = bq(@next);
}