use darling::FromDeriveInput;
use proc_macro::TokenStream;
use proc_macro2::Ident;
use quote::quote;
use syn::parse_macro_input;

fn generate_struct_debuggable(
    _original_name: &Ident,
    debuggable_name: &Ident,
    fields: &syn::Fields,
    generics: &syn::Generics,
    context_type: &syn::Path,
) -> (proc_macro2::TokenStream, proc_macro2::TokenStream) {
    match fields {
        syn::Fields::Named(fields_named) => {
            let debuggable_fields = fields_named.named.iter().map(|field| {
                let field_name = &field.ident;
                let field_type = &field.ty;
                quote! {
                    #field_name: <#field_type as debug_with_trait::DebugWith<#context_type>>::Output<'a>,
                }
            });

            let convert_fields = fields_named.named.iter().map(|field| {
                let field_name = &field.ident;
                quote! {
                    #field_name: debug_with_trait::DebugWith::<#context_type>::convert(&self.#field_name, context),
                }
            });

            let (_impl_generics, _ty_generics, where_clause) = generics.split_for_impl();

            let debuggable_type = quote! {
                /// A debuggable wrapper type generated by the DebugWith derive macro
                #[derive(Debug)]
                pub struct #debuggable_name<'a> #where_clause {
                    #(#debuggable_fields)*
                }
            };

            let convert_impl = quote! {
                #debuggable_name {
                    #(#convert_fields)*
                }
            };

            (debuggable_type, convert_impl)
        }
        syn::Fields::Unnamed(fields_unnamed) => {
            let debuggable_fields = fields_unnamed
                .unnamed
                .iter()
                .enumerate()
                .map(|(_i, field)| {
                    let field_type = &field.ty;
                    quote! {
                        <#field_type as debug_with_trait::DebugWith<#context_type>>::Output<'a>,
                    }
                });

            let convert_fields = fields_unnamed.unnamed.iter().enumerate().map(|(i, _)| {
                let index = syn::Index::from(i);
                quote! {
                    debug_with_trait::DebugWith::<#context_type>::convert(&self.#index, context),
                }
            });

            let (_impl_generics, _ty_generics, where_clause) = generics.split_for_impl();

            let debuggable_type = quote! {
                /// A debuggable wrapper type generated by the DebugWith derive macro
                #[derive(Debug)]
                pub struct #debuggable_name<'a>(
                    #(#debuggable_fields)*
                ) #where_clause;
            };

            let convert_impl = quote! {
                #debuggable_name(
                    #(#convert_fields)*
                )
            };

            (debuggable_type, convert_impl)
        }
        syn::Fields::Unit => {
            let (_impl_generics, _ty_generics, _where_clause) = generics.split_for_impl();

            let debuggable_type = quote! {
                /// A debuggable wrapper type generated by the DebugWith derive macro
                #[derive(Debug)]
                pub struct #debuggable_name<'a>(::std::marker::PhantomData<&'a ()>);
            };

            let convert_impl = quote! {
                #debuggable_name(::std::marker::PhantomData)
            };

            (debuggable_type, convert_impl)
        }
    }
}

fn generate_enum_debuggable(
    original_name: &Ident,
    debuggable_name: &Ident,
    variants: &syn::punctuated::Punctuated<syn::Variant, syn::token::Comma>,
    generics: &syn::Generics,
    context_type: &syn::Path,
) -> (proc_macro2::TokenStream, proc_macro2::TokenStream) {
    let debuggable_variants = variants.iter().map(|variant| {
        let variant_name = &variant.ident;
        match &variant.fields {
            syn::Fields::Named(fields_named) => {
                let debuggable_fields = fields_named.named.iter().map(|field| {
                    let field_name = &field.ident;
                    let field_type = &field.ty;
                    quote! {
                        #field_name: <#field_type as debug_with_trait::DebugWith<#context_type>>::Output,
                    }
                });
                quote! {
                    #variant_name {
                        #(#debuggable_fields)*
                    }
                }
            }
            syn::Fields::Unnamed(fields_unnamed) => {
                let debuggable_fields = fields_unnamed.unnamed.iter().map(|field| {
                    let field_type = &field.ty;
                    quote! {
                        <#field_type as debug_with_trait::DebugWith<#context_type>>::Output<'a>,
                    }
                });
                quote! {
                    #variant_name(
                        #(#debuggable_fields)*
                    )
                }
            }
            syn::Fields::Unit => {
                quote! {
                    #variant_name(::std::marker::PhantomData<&'a ()>)
                }
            }
        }
    });

    let convert_match_arms = variants.iter().map(|variant| {
        let variant_name = &variant.ident;
        match &variant.fields {
            syn::Fields::Named(fields_named) => {
                let field_names: Vec<_> = fields_named.named.iter().map(|f| &f.ident).collect();
                let convert_fields = field_names.iter().map(|field_name| {
                    quote! {
                        #field_name: debug_with_trait::DebugWith::<#context_type>::convert(#field_name, context),
                    }
                });
                quote! {
                    #original_name::#variant_name { #(#field_names,)* } => {
                        #debuggable_name::#variant_name {
                            #(#convert_fields)*
                        }
                    }
                }
            }
            syn::Fields::Unnamed(fields_unnamed) => {
                let field_count = fields_unnamed.unnamed.len();
                let field_names: Vec<_> = (0..field_count)
                    .map(|i| Ident::new(&format!("field_{}", i), original_name.span()))
                    .collect();
                let convert_fields = field_names.iter().map(|field_name| {
                    quote! {
                        debug_with_trait::DebugWith::<#context_type>::convert(#field_name, context),
                    }
                });
                quote! {
                    #original_name::#variant_name(#(#field_names,)*) => {
                        #debuggable_name::#variant_name(
                            #(#convert_fields)*
                        )
                    }
                }
            }
            syn::Fields::Unit => {
                quote! {
                    #original_name::#variant_name => {
                        #debuggable_name::#variant_name(::std::marker::PhantomData)
                    }
                }
            }
        }
    });

    let (_impl_generics, _ty_generics, _where_clause) = generics.split_for_impl();

    let debuggable_type = quote! {
        /// A debuggable wrapper type generated by the DebugWith derive macro
        #[derive(Debug)]
        pub enum #debuggable_name<'a> {
            #(#debuggable_variants,)*
        }
    };

    let convert_impl = quote! {
        match self {
            #(#convert_match_arms,)*
        }
    };

    (debuggable_type, convert_impl)
}

/// Options for the DebugWith derive macro
#[derive(Debug, FromDeriveInput)]
#[darling(attributes(debug_with))]
struct DebugWithOptions {
    /// The context type parameter C for DebugWith<C>
    #[darling(default)]
    context: Option<syn::Path>,
    /// If true, implement DebugWith for any C by cloning self
    #[darling(default)]
    passthrough: bool,
}

/// Derive macro for the DebugWith trait
#[proc_macro_derive(DebugWith, attributes(debug_with))]
pub fn debug_with_derive(input: TokenStream) -> TokenStream {
    // Parse the input tokens into a syntax tree
    let input = parse_macro_input!(input as syn::DeriveInput);

    // Parse the options using Darling
    let opts = match DebugWithOptions::from_derive_input(&input) {
        Ok(opts) => opts,
        Err(e) => {
            return TokenStream::from(e.write_errors());
        }
    };

    // Get the name of the type we're deriving for
    let name = &input.ident;

    // Check if passthrough mode is enabled
    if opts.passthrough {
        // Passthrough mode: implement for any C, just clone self
        let expanded = quote! {
            impl<C> debug_with_trait::DebugWith<C> for #name {
                type Output<'a>
                    = #name
                where
                    Self: 'a,
                    C: 'a;

                fn convert<'a>(&self, _context: &'a C) -> Self::Output<'a> {
                    self.clone()
                }
            }
        };
        return TokenStream::from(expanded);
    }

    // Normal mode: require context type
    let context_type = match opts.context.as_ref() {
        Some(ctx) => ctx,
        None => {
            return syn::Error::new(
                name.span(),
                "DebugWith derive requires either `context` or `passthrough` attribute",
            )
            .to_compile_error()
            .into();
        }
    };

    // Generate the name for the debuggable type
    let debuggable_name = Ident::new(&format!("{}Debuggable", name), name.span());

    // Generate the debuggable type and convert implementation based on data type
    let (debuggable_type, convert_impl) = match &input.data {
        syn::Data::Struct(data) => generate_struct_debuggable(
            name,
            &debuggable_name,
            &data.fields,
            &input.generics,
            context_type,
        ),
        syn::Data::Enum(data) => generate_enum_debuggable(
            name,
            &debuggable_name,
            &data.variants,
            &input.generics,
            context_type,
        ),
        syn::Data::Union(_) => {
            return syn::Error::new(
                name.span(),
                "DebugWith derive macro does not support unions",
            )
            .to_compile_error()
            .into();
        }
    };

    // Generate the trait implementation
    let expanded = quote! {
        #debuggable_type

        impl debug_with_trait::DebugWith<#context_type> for #name {
            type Output<'a> = #debuggable_name<'a>;

            fn convert<'a>(&self, context: &'a #context_type) -> Self::Output<'a> {
                #convert_impl
            }
        }
    };

    // Hand the output tokens back to the compiler
    TokenStream::from(expanded)
}
